# This file was created by Yombo for use with Yombo Python gateway automation
# software.  Details can be found at https://yombo.net
"""
.. note::

  * For library documentation, see: `MQTT @ Library Documentation <https://yombo.net/docs/libraries/mqtt>`_

Handles the MQTT connection. Responsible for resubscribing to any topics, etc.
Implements MQTT. It does 2 things:

*Usage**:

.. code-block:: python

   def _init_(self):
       # Create anew connection. Hostname, port, user, password, ssl(True/False) can be specified if connection
       # to anther MQTT server. Otherwise, use the default local one.
       self.my_mqtt = self._MQTT.new(on_message_callback=self.mqtt_incoming)  # Create a new connection to the embedded MQTT server.

       # Subscribe to all topics of "foor/bar/topic" and send them to:  self.mqtt_incoming
       self.my_mqtt.subscribe("foo/bar/topic")
       d = self.my_mqtt.publish("for/bar/topic/status", "on")  # publish a message  # returns a deferred. Can be used to
       # stack more commands or do something after the message has been published.


   def mqtt_incoming(self, topic, payload, qos, retain):
       print(f"topic: {topic}")
       print(f"message: {message}"_


.. moduleauthor:: Mitch Schwenk <mitch-gw@yombo.net>
.. versionadded:: 0.24.0


:copyright: Copyright 2019-2020 by Yombo.
:license: LICENSE for details.
:view-source: `View Source Code <https://yombo.net/docs/gateway/html/current/_modules/yombo/lib/mqtt/__init__.html>`_
"""
# Import python libraries
import asyncio
from collections import deque, Callable, OrderedDict
from gmqtt import Client as QClient, Message as QMessage
from typing import Any, ClassVar, Dict, List, Optional, Type, Union

# Import twisted libraries
from twisted.internet.defer import inlineCallbacks, Deferred

# Import Yombo libraries
from yombo.core.entity import Entity
from yombo.core.exceptions import YomboWarning
from yombo.core.log import get_logger

logger = get_logger("library.mqtt.mqttclient")


class MQTTClient(Entity):
    """
    A helper class for MQTT. Handles all the connection details. Returned to the library or module
    that calls self._MQTTYombo.new().

    .. code-block:: python

       self.my_mqtt = self._MQTT.new(on_message_callback=self.mqtt_incoming, client_id="my_client_name")
       self.my_mqtt.subscribe("yombo/devices/+/get")  # subscribe to a topic. + is a wildcard for a single section.
    """
    def __init__(self, parent, hostname: Optional[str] = None, port: Optional[int] = None,
                 username: Optional[str] = None, password: Optional[str] = None, use_ssl: Optional[bool] = None,
                 version: Optional[str] = None, keepalive: Optional[int] = None, session_expiry: Optional[int] = None,
                 receive_maximum: Optional[int] = None, user_property: Optional[Union[tuple, List[tuple]]] = None,
                 last_will: Optional = None, maximum_packet_size: Optional[int] = None,
                 on_message_callback: Callable = None, subscribe_callback: Callable = None,
                 unsubscribe_callback: Callable = None, connected_callback: Optional[Callable] = None,
                 disconnected_callback: Optional[Callable] = None, error_callback: Optional[Callable] = None,
                 client_id: Optional[str] = None, password2: Optional[str] = None):
        """
        Creates a new client connection to an MQTT broker.
        :param parent: A reference to the MQTT library.
        :param hostname: IP address or hostname to connect to.
        :param port: Port number to connect to.
        :param username: Username to connect as. Use "" to not use a username & password.
        :param password: Password to to connect with. Use "" to not use a password.
        :param use_ssl: Use SSL when attempting to connect to server, default is True.
        :param version: MQTT version to use, default: MQTTv50. Other: MQTTv311
        :param keepalive: How often the connection should be checked that it's still alive.
        :param session_expiry: How many seconds the session should be valid. Defaults to 0.
        :param receive_maximum: The Client uses this value to limit the number of QoS 1 and QoS 2 publications that it
               is willing to process concurrently.
        :param user_property: Connection user_property. A tuple or list of tuples.
        :param last_will: Last will message generated by 'will()'.
        :param maximum_packet_size: The maximum size the mqtt payload should be, in size.
        :param on_message_callback: (required) method - Method to send messages to.
        :param connected_callback: method - If you want a function called when connected to server.
        :param disconnected_callback: method - If you want a function called when disconnected from server.
        :param subscribe_callback: method - This method will be called when successfully subscribed to topic.
        :param unsubscribe_callback: method - This method will be called when successfully unsubscribed from topic.
        :param error_callback: method - A function to call if something goes wrong.
        :param client_id: (default - random) - A client id to use for logging.
        :param password2: A second password to try. Used by MQTTYombo.
        :return:
        """
        self._Entity_type: str = "MQTTClient"
        self._Entity_label_attribute: str = "client_id"
        super().__init__(parent)

        self.connected = False
        self.incoming_duplicates = deque([], 150)
        self.send_queue = deque()
        self.subscriptions = {}
        self.unsubscriptions = {}

        self.topics = {}  # Store topics to resubscribe to

        self.hostname = hostname
        self.port = port
        self.username = username
        self.password = password
        self.password2 = password2
        self.use_ssl = use_ssl
        self.version = version
        self.keepalive = keepalive
        self.session_expiry = session_expiry
        self.receive_maximum = receive_maximum
        self.user_property = user_property
        self.last_will = last_will
        self.maximum_packet_size = maximum_packet_size
        self.on_message_callback = on_message_callback
        self.subscribe_callback = subscribe_callback
        self.unsubscribe_callback = unsubscribe_callback
        self.connected_callback = connected_callback
        self.disconnected_callback = disconnected_callback
        self.error_callback = error_callback
        self.client_id = client_id

        client_options = {
            "receive_maximum": receive_maximum,
            "session_expiry_interval": session_expiry,
            "maximum_packet_size": maximum_packet_size,
            "user_property": user_property,
        }
        self.client = QClient(client_id, **{k: v for k, v in client_options.items() if v is not None})
        self.client.set_auth_credentials(username, password.encode())
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message_callback
        self.client.on_disconnect = self.on_disconnect
        self.client.on_subscribe = self.on_subscribe

    @inlineCallbacks
    def connect(self):
        """Connects to the mqtt broker."""
        d = self.as_deferred(self.do_connect())
        yield d

    def as_deferred(self, f):
        return Deferred.fromFuture(asyncio.ensure_future(f))

    async def do_connect(self):
        """Connects to the mqtt broker."""
        await asyncio.create_task(self.client.connect(host=self.hostname, port=self.port))

    def on_connect(self, client, flags, rc, properties):
        """Received a message."""
        self.connected = True
        # Do subscribes
        for topic, kwargs in self.subscriptions.items():
            self.client.subscribe(topic, **kwargs)
        for topic, kwargs in self.unsubscriptions.items():
            self.client.unsubscribe(topic, **kwargs)

        # Do messages
        for message in self.send_queue:
            self.client.publish(message["topic"], **message["kwargs"])

        if callable(self.connected_callback):
            self.connected_callback(properties=properties)

    def on_disconnect(self, client, packet, exc=None):
        """Disconnected notification."""
        self.connected = False
        if callable(self.disconnected_callback):
            self.disconnected_callback(client=client, packet=packet)

    def on_message(self, client, topic, body, qos, properties):
        """Received a message."""
        if callable(self.on_message_callback):
            self.on_message_callback(client=client, topic=topic, body=body, qos=qos, properties=properties)

    def on_subscribe(self, client, mid, qos, properties):
        """Received subscribe confirmation."""
        if callable(self.subscribe_callback):
            self.subscribe_callback(client=client, mid=mid, qos=qos, properties=properties)

    def on_unsubscribe(self, client, mid, qos):
        """Received unsubscribe confirmation."""
        if callable(self.unsubscribe_callback):
            self.unsubscribe_callback(client=client, mid=mid, qos=qos)

    def subscribe(self, topic: str, **kwargs):
        """
        Subscribe to a topic.

        :param topic:
        :param kwargs:
        :return:
        """
        if "qos" not in kwargs:
            kwargs["qos"] = 1
        if self.session_expiry == 0:
            self.subscriptions[topic] = kwargs

        if self.connected is True:
            self.client.subscribe(topic, **kwargs)

    def unsubscribe(self, topic: str, **kwargs):
        """
        Unsubscribe from topic.

        :param topic: Topic to unsubscribe from.
        :param kwargs:
        :return:
        """
        if "qos" not in kwargs:
            kwargs["qos"] = 1
        if self.connected is True:
            self.client.unsubscribe(topic, **kwargs)

        if self.session_expiry == 0:
            self.unsubscriptions[topic] = kwargs

    def publish(self, topic: str, message: Optional[str] = None, qos: Optional[int] = None, **kwargs):
        """
        Publish a message to the MQTT broker. If not connected yet, will hold in a queue for later.

        :param topic: Topic to publish too.
        :param message: Message to send.
        :param qos: quality of service.
        :param kwargs: Any additional items to send to the qmqtt publish command.
        :return:
        """
        if qos is None:
            qos = 1
        if self.connected is True:
            self.client.publish(topic, payload=message, qos=qos, **kwargs)
        else:
            kwargs["message"] = message
            kwargs["qos"] = qos
            self.send_queue.append({"topic": topic, "kwargs": kwargs})
